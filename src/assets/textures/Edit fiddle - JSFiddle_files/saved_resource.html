<!DOCTYPE html>
<!-- saved from url=(0034)http://fiddle.jshell.net/_display/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  

  
  
  

  

  <script type="text/javascript" src="./dummy.js"></script>

  

  

  

  
    <link rel="stylesheet" type="text/css" href="./result-light.css">
  

  

  <style type="text/css">
    
  </style>

  <title></title>

  
    




<script type="text/javascript">//<![CDATA[
window.onload=function(){
        var container;
        var camera, controls, scene, renderer;

        init();
        animate();

        function init() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 1000;

            controls = new THREE.OrbitControls(camera);

            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            controls.noZoom = false;
            controls.noPan = false;

            controls.staticMoving = true;
            controls.dynamicDampingFactor = 0.3;

            controls.keys = [65, 83, 68];

            controls.addEventListener('change', render);

            // world

            scene = new THREE.Scene();
            sceneTarget = new THREE.Scene();

            var testObject_G = new THREE.CubeGeometry(100, 100, 5);
            var testObject_M = new THREE.MeshBasicMaterial({
                color: 0xBBBBBB
            });
            var testObject_Mesh = new THREE.Mesh(testObject_G, testObject_M);
            testObject_Mesh.position.x = -150;
            scene.add(testObject_Mesh);
            var testObject_Mesh2 = new THREE.Mesh(testObject_G, testObject_M);
            testObject_Mesh2.position.x = 0;
            scene.add(testObject_Mesh2);
            var testObject_Mesh3 = new THREE.Mesh(testObject_G, testObject_M);
            testObject_Mesh3.position.x = 150;
            scene.add(testObject_Mesh3);

            var targetObject_G = new THREE.SphereGeometry( 5 );
            var targetObgect_M = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            
            var targetMesh = new THREE.Mesh(targetObject_G, targetObgect_M);
            targetMesh.position.set( 0, 200, -200 );
            sceneTarget.add(targetMesh);
            
            // renderer

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            renderer.setClearColor(0xffffff, 1);
            container = document.getElementById('container');
            container.appendChild(renderer.domElement);



            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            controls.handleResize();

            render();

        }

        function animate() {

            requestAnimationFrame(animate);
            controls.update();

        }

        function render() {

            renderer.render(scene, camera);
            renderer.render(sceneTarget, camera);
            castRays();

        }

        function castRays() {
            
            // rays

            var direction = new THREE.Vector3(0, 100, -100);
            
            var startPoint = camera.position.clone();
            
            var directionVector = direction.sub( startPoint );

            var ray = new THREE.Raycaster(startPoint, directionVector.clone(). normalize());
            
            scene.updateMatrixWorld(); // required, since you haven't rendered yet
            
            var rayIntersects = ray.intersectObjects(scene.children, true);
            
            if (rayIntersects[0] && rayIntersects[0].distance < directionVector.length()) {
                console.log(rayIntersects[0]);

                var material = new THREE.LineBasicMaterial({
                  color: 0x0000ff
                });
                var geometry = new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3(ray.ray.origin.x, ray.ray.origin.y, ray.ray.origin.z));
                geometry.vertices.push(new THREE.Vector3(0, 200, -200));
                var line = new THREE.Line(geometry, material);
                sceneTarget.add( line );
                
            }
            
        }
}//]]> 

</script>

  
</head>

<body>
  <script src="./three.min.js"></script>
<script src="./OrbitControls.js"></script>
<div id="container"><canvas width="839" height="671" style="width: 839px; height: 671px;"></canvas></div>
  
  <script>
  // tell the embed parent frame the height of the content
  if (window.parent && window.parent.parent){
    window.parent.parent.postMessage(["resultsFrame", {
      height: document.body.getBoundingClientRect().height,
      slug: "None"
    }], "*")
  }
</script>





</body></html>